# Chp3. 타입과 추상화

<aside>
💡 추상화를 통한 복잡성 극복?

</aside>

- 추상화
    - 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법
- 추상화의 두 차원
    - 사물들 간 공통점 취하고, 차이점 버림
    - 불필요한 세부사항 제거

<aside>
💡 공통점을 기반으로 객체들을 묶기 위한 그릇 == 개념

</aside>

- 개념(concept)
    - 개념을 이용하면 객체를 여러 그룹으로 분류할 수 있다.
    - 공통점을 기반으로 객체들을 묶는 기준
- 인스턴스(instance)
    - 객체가 개념 그룹의 일원이 될때 그 객체를 개념의 인스턴스라고 한다.
    - 객체 : 특정한 개념을 적용할 수 있는 구체적 사물. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.

<aside>
💡 개념의 세 가지 관점

</aside>

- 심볼(symbol) : 개념을 가리키는 간략한 이름이나 명칭
    - ex) 트럼프
- 내연(intension) : 개념의 완전한 정의. 내연의 의미를 이용해 객체가 개념에 속하는지 여부 판단
    - ex) 몸이 납작, 팔다리가 네모난 몸 모서리에 달려있다
- 외연(extension) : 개념에 속하는 모든 객체의 집합(set)
    - ex) 병사, 신하, 왕자와 공주, 왕 왕비, 하트 잭, 하트 왕 등

<aside>
💡 객체를 분류하기 위한 틀

</aside>

- 분류 : 객체에 특정한 개념을 적용하는 작업.
    - 객체에 특정한 개념이 적용되면, 그 객체를 특정한 집합의 멤버로 분류한다.

<aside>
💡 분류는 어떻게 할까?

</aside>

- 분류는 추상화를 위한 도구
    - 구체적인 사물간의 공통점은 취하고, 차이점은 버리는 일반화를 통해 단순화 한다.
    - 중요한 부분을 강조하기 위해 불필요한 세부사항을 제거한다.

<aside>
💡 타입이란 뭘까?

</aside>

- 타입 == 개념
- 타입은 공통점을 기반으로 객체들을 묶기위한 틀
    - 객체 역시 타입의 인스턴스라고 한다.
    - 심볼, 내연, 외연을 이용해 서술할 수 있다.
    - 단, 컴퓨터 내부로 들어오는 순간 조금 더 기계적인 의미로 바뀐다.

<aside>
💡 타입에 관련된 중요한 두 가지 사실

</aside>

- 타입은 데이터가 어떻게 사용되느냐에 관한 것
    - 어떤 데이터에 어떤 연산자를 적용할수 있는가가 데이터 타입을 결정한다.
- 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰진다.
    - 개발자는 데이터 타입을 사용하기 위해 데이터 타입에 적용할 연산자만 알고 있으면 된다.
    - 즉, 메모리에 데이터가 어떤 방식으로 저장되는지 몰라도 된다.

<aside>
💡 객체와 타입의 연관성?

</aside>

- 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동에 따라 결정된다.
    - 어떤 객체들이 동일한 행동을 수행한다면, 그 객체들은 동일한 타입
- 객체의 내부적인 표현은 외부로부터 철저히 감춰진다
- p.92 내용이 일부 지워져서 다시 봐야할듯.

<aside>
💡 객체는 행동이 우선!

</aside>

- 객체의 타입 ⇒ 객체의 행동에 따라 결정
    - 동일한 데이터를 가지는지는 중요하지 않음
    - 동일한 행동 == 동일한 책임 == 동일한 메시지 수신
- 다형성에 의미를 부여
    - 다형성 : 동일한 메시지를 다른 방식으로 처리
    - 즉, 동일한 메시지를 받을 수 있어야한다. == 동일한 타입의 객체(또는 타입계층)
- 행동만이 고려대상 ⇒ 내부 표현방식과 무관 ⇒ 외부에 데이터를 감춰야함 ⇒ 캡슐화

<aside>
💡 책임 주도 설계(Responsibility-Driven Design)

</aside>

- 데이터 주도 설계 방법의 단점을 개선하기 위해 고안됨
- 객체 설계 방식
    - 객체가 외부에 제공해야하는 책임을 먼저 결정
    - 책임을 수행하는데 적합한 데이터를 결정
    - 데이터를 책임 수행하는데 필요한 외부 인터페이스 뒤로 캡슐화
    - 즉, 데이터를 먼저 결정하고,객체의 책임을 결정하는 방법은 유연하지 못한 설계!

<aside>
💡 일반화&특수화 관계

</aside>

- 일반화&특수화 관계를 결정하는 것은 객체가 외부에 제공하는 행동이다
- 일반적인 타입 : 더 적은 수의 행동
    - 더 큰 크기의 외연집합
- 특수한 타입 : 더 많은 수의 행동
    - 더 적은 크기의 외연집합
    - 일반적인 타입이 가진 행동을 특수한 타입이 전부 수행할 수 있음.

<aside>
💡 슈퍼타입과 서브타입

</aside>

- 슈퍼타입 : 일반적인 타입
- 서브 타입 : 특수한 타입
    - 슈퍼타입과 호환됨 ⇒ 슈퍼타입을 대체할 수 있어야함
    - 슈퍼타입의 행동은 서브타입에 자동으로 상속된다.

<aside>
💡 왜 타입을 사용해야할까?

</aside>

- 동적으로 변화하는 객체의 복잡성을 극복하기 어렵기 때문
    - 객체의 상태가 변화하지만 식별성은 동일하게 유지됨 ⇒ 시간과 무관하게 정적인 관점에서 다룰 수 있게 해줌
- 즉, 타입 == 추상화
    - 시간 & 상태변화 요소를 제거하고 정적인 관점에서 객체를 표현할 수 있음

<aside>
💡 객체의 모델 두 가지

</aside>

- 동적 모델
    - 스냅샷(snapshot)
        - 객체가 특정 시점에 구체적으로 어떤 상태를 가지는지
        - UML에서는 Object Diagram이라고 불린다.
- 정적 모델(타입모델, type diagram)
    - 객체의 상태와 행동을 시간에 독립적으로 표현

<aside>
💡 클래스

</aside>

- 정적인 모델은 클래스를 이용해 구현된다.
    - 즉, 타입을 구현하는 가장 보편적인 방법
- 클래스 ≠ 타입
    - 클래스 == 타입을 구현할 수 있는 메커니즘
- 결론
    - 객체를 분류하는 기준 == 타입
    - 타입을 나누는 기준 == 객체가 수행하는 행동
    - 타입을 구현하는 방법 == 클래스