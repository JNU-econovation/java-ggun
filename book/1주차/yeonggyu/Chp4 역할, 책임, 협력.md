# Chp4. 역할, 책임, 협력

<aside>
💡 객체의 세계에서 문맥

</aside>

- 문맥 : 객체의 행동방식을 결정
- 자주하는 실수
    - 협력이라는 문맥을 고려하지 않고 객체가 가져야할 상태와 행동부터 고민하기 시작한다는 것.
    - 협력 고려 → 행동 드러남 → 상태 결정

<aside>
💡 협력이란 무엇일까?

</aside>

- 협력 : 다수의 연쇄적인 요청과 응답의 흐름으로 구성된다.
    - 요청과 응답 → 협력에 참여하는 객체가 수행할 책임 정의

<aside>
💡 요청과 응답의 예시(질문)

</aside>

- **왕**에게 ‘**재판**’ **요청**
- **왕**이 **하얀 토끼**에게 **증인을 부를 것**을 **요청**
- 요청받은 **토끼**는 **모자장수**에게 **증인석으로 입장할 것**을 **요청**
- **모자장수**의 입장은 **왕**이 **토끼**에게 요청했던 중인 호출에 대한 **응답**
- **왕**은 **모자장수**에게 **증언할 것**을 **요청**
- **모자 장수**는 자신이 알고 있는 **내용을 증언함**으로써 **왕**의 요청에 **응답**
- 그럼 여기서 객체는?
    - 왕, 하얀토끼, 모자장수
- 여기서 행동은?
    - 증인 부를것, 증인석으로 입장할 것, 증언할 것, 내용을 증언함
- 여기서 상태는?
    - 입장 유무, 증언 유무, 증인 유무, 내용 유무? 맞나?
- 요청과 응답에 필요한 것
    - 요청에 대해 적절한 방식으로 응답하는 데 필요한 지식과 행동 방식

<aside>
💡 책임이란 무엇일까?

</aside>

- 적절한 행동을 할 의무가 있는 경우 == 객체가 책임을 가진다.
- 대상이 요청을 처리할 책임
- 책임은 무엇을 알고 있는가와 무엇을 할 수 있는가로 구성된다

<aside>
💡 책임의 분류

</aside>

- 객체의 책임은 하는것과 아는것으로 나뉜다.
- 하는 것(doing)
    - 객체를 생성하거나, 계산을 하는 등의 스스로 하는 것
    - 다른 객체의 행동을 시작시키는 것
    - 다른 객체의 활동을 제어하고 조절하는 것
- 아는 것(knowing)
    - 개인적인 정보에 관해 아는 것
    - 관련된 객체에 관해 아는 것
    - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

<aside>
💡 왕과 토끼와 모자장수에 대해 궁금한점 p.116

</aside>

- 왕과 토끼와 모자장수를 MVC로 적용시킬 수 있을까?
    - 왕 : controller - 다른 객체들의 활동을 제어하고 조율
    - 토끼 : model - 비지니스 로직같음
    - 모자장수 : View - 증언을 반환하니까..?

<aside>
💡 책임과 메시지

</aside>

- 메시지 전송 : 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것
    - 송신자 : 메시지 전송하고, 요청하는 객체
    - 수신자 : 요청을 처리하는 객체
- 주의할 점
    - 책임 수준 ≠ 메시지 수준
        - 무슨 의미지?
            - 책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할되는 것이 일반적
        - 설계 시작 초반에는 어떤 객체가 어떤 책임을 가지고 어떤 방식으로 서로 협업을 해야하는지에 대한 개요를 아는 것만으로도 충분

<aside>
💡 역할이란?

</aside>

- 역할 : 어떤 객체가 협력 안에서 수행하는 책임의 집합
- 판사 : 왕, 여왕
- 증인 : 모자장수, 요리사, 앨리스
- 즉, 판사와 증인은 역할(role)임
- 역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식
- 역할
    - 단순성 : 유사한 협력을 추상화 → 인지과부화 줄임
    - 유연성 : 협력이 유연해짐
    - 재사용성 : 재사용성이 높아짐

<aside>
💡 협력의 추상화

</aside>

- 설계자가 다뤄야하는 협력의 개수를 줄임
- 구체적인 객체를 추상적인 역할로 대체 → 협력의 양상 단순화 → 설계를 이해하고 기억하기 쉬워짐
- 역할을 이용하면 협력을 추상화함으로 단순화 할 수 있다.
- 단, 역할의 대체 가능성에 비롯됨

<aside>
💡 대체 가능성이란?

</aside>

- 대체 가능함의 조건
    - 역할이 수행하는 모든 책임을 동일하게 수행할 수 있어야 한다.
- 그렇다면?
    - 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다.
    - 역할이 협력을 추상적으로 만들 수 있는 이유는?
        - 역할 == 객체의 추상화이기 때문
- 역할의 대체 가능성 == 행위 호환성 == 동일한 책임의 수행

<aside>
💡 객체지향에 대한 선입견

</aside>

- 첫째 : 데이터를 저장하기위한 객체?
    - 데이터 == 객체가 행위 수행하는 데 필요한 재료
    - 실제 중요한 것 == 객체의 행동 == 책임
- 둘째 : 클래스와 클래스의 관계를 표현하는 정적인 측면에 중점을 둘까?
    - 중요한 것 == 동적인 객체
    - 클래스 == 시스템에 필요한 객체를 표현하고 생성하기 위한 구현 메커니즘
- 데이터 & 클래스 중심 설계 ⇒ 협력이라는 문맥을 고려하지 않고 각 객체를 독립적으로 보기 때문

<aside>
💡 올바른 객체 설계

</aside>

- 올바른 객체 설계 → 견고하고 깔끔한 협력 설계 == 요청과 응답의 흐름 결정 → 수행될 책임
- 객체에게 책임 할당 → 책임은 객체가 외부에 제공할 행동이됨 → 행동 결정 → 데이터 결정 → 클래스 구현방법 결정
- 협력이라는 실행문맥 안에서 → 책임을 분배
    - 객체를 충분히 협력적으로 만듦
    - 협력 문맥 내에서 객체를 충분히 자율적으로 만듦

<aside>
💡 객체지향 설계 기법

</aside>

- 책임-주도 설계(Responsibility-Driven Design)
    - 협력에 필요한 책임 식별, 적합한 객체에게 책임 할당
- 디자인 패턴(Design Pattern)
    - 전문가들이 반복적으로 사용하는 해결방법을 정의해 놓은 설계 탬플릿의 모음
- 테스트-주도 개발(Test-Driven Development)
    - 테스트 먼저 작성 후, 테스트 통과하는 구체적인 코드를 추가하면서 애플리케이션 완성하는 방식
    - TDD는 테스트가 아닌, 설계를 위한 기법
    - 역할,책임,협력을 식별하고, 적합한지 피드백받는 것이 목적

<aside>
💡 책임-주도 설계

</aside>

- 객체의 책임을 중심으로 시스템을 구축하는 설계방법
- 시스템 책임 → 객체의 책임으로 변환 → 각 객체는 협력자에게 책임을 할당 → 협력 공동체 구축
- 개별적인 객체의 상태가 아닌, 객체의 책임과 상호작용에 집중
- 절차
    - 시스템이 사용자에게 제공해야하는 기능인 시스템 책임 파악
    - 시스템 책임을 더 작은 책임으로 분할
    - 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다
    - 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
    - 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.

<aside>
💡 디자인 패턴

</aside>

- 모범이 되는 설계
- 반복적으로 발생하는 문제와 문제에 대한 해법의 쌍
- 해결하려고 하는 문제가 무엇인지, 패턴을 적용할 수 있는 상황, 적용할 수 없는 상황을 함께 설명한다.
- 약 23개 있음

<aside>
💡 테스트-주도 개발

</aside>

- 기본 흐름
    - 실패하는 테스트를 작성
    - 테스트를 통과하는 가장 간단한 코드 작성
    - 리팩터링을 통해 중복 제거
    - clean code 얻을 수 있음
- 응집도 높고 결합도 낮은 클래스로 구성된 시스템을 개발할 수 있게 하는 최상의 프랙티스
- 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할 것인지에 관해 먼저 생각해야함.
- TDD는 책임-주도 설계의 기본개념을 따른다.