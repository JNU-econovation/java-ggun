# 04. 역할, 책임, 협력

page. 106 ~ 137

좋은 객체지향 설계 - 조화를 이루며 협력적인 객체

객체의 행동. 상태가 아닌 객체들 간의 협력에 집중!

## 협력

### 요청하고 응답하며 협력하는 사람들

협력 - 도움을 요청할 때 시작.

스스로 해결하기 어려운 문제에 대해 도움 요청

요청을 받으면 일 처리 후 필요한 지식이나 서비스 제공

### 누가 파이를 훔쳤지?

객체들은 하트 잭의 재판이라는 동일한 목적을 달성하기 위해 협력

### 재판 속의 협력

증언을 듣는 과정에서 요청과 응답

요청과 응답은 협력에 참여하는 객체가 수행할 책임

## 책임

객체와 책임이 정해지지 않은 상태에서 구현하는 것은 변경에 취약하고 다양한 협력에 참여할 수 없는 비자율적인 객체를 만들게 된다.

### 책임의 분류

객체의 책임

- 객체가 무엇을 알고 있는가(Knowing)
- 객체가 무엇을 할 수 있는가(Doing)

Doing

- 객체를 생성하거나 계산
- 다른 객체의 행동 시작
- 다른 객체의 활동 제어, 조절

Knowing

- 개인적인 정보 아는 것
- 관련된 객체에 관해 아는 것
- 자신이 유도하거나 계산할 수 있는 것을 아는 것

명확하 책임이 앱의 미래를 결정!

책임은 객체의 외부에 제공할 수 있는 정보, 제공해줄 수 있는 서비스의 목록

책임은 객체의 공용 인터페이스!! 를 구성

공용 인터페이스 → 캡슐화로 이어짐

### 책임과 메시지

메시지 전송 - 요청을 보내는 것

송신자 : 메시지를 전송하는 객체(협력 요청)

수신자 : 메시지 받는 객체(요청 처리)

요청을 전송한다는 것은 수신한 객체가 책임을 수행하게 한다.

책임이 협력에서는 수신자에게 무엇을 할수있는지 나열하는 것이라면

메시지는 협력에 참여하는 두 객체의 사이 관계를 강조하는 것

상호 협력!!

송신자는 알맞은 메시지를 전송, 수신자는 메시지에 대해 적절한 책임 수행!

협력 중에 책임이 여러 메시지로 분할됨.

클래스와 메서드는 책임과 메시지를 정한 후에 시작해도 된다.

## 역할

### 책임의 집합이 의미하는 곳

책임의 집합 - 협력안에서 수행하는 역할!

협력이 너무 비슷해 → 하나로 줄이면 어떨까?

### 판사와 증인

### 역할이 답이다

역할을 사용한다면 하나의 협력으로 추상화 가능!!

역할을 수행할 수 있는 객체들 - 메시지를 동일하게 이해하고 처리 가능

** 동일한 역할을 수행하는 객체들이 동일한 메시지를 수신할 수 있기 때문에 동일한 책임을 수행할 수 있다**

역할을 사용하면 유사한 협력 추상화 - 인지과부하 줄임

역할은

- 단순성
- 유연성
- 재사용성

### 협력의 추상화

역할 - 추상화 → 단순화

### 대체 가능성

객체가 어느 역할에 들어가려면 협력 안에서 그 역할이 수행하는 모든 행동을 수행할 수 있어야 한다.

하지만 객체는 역할에 주어진 책임 이외에 다른 책임도 수행할 수 있다!!

역할 ⊆ 객체

**역할의 대체 가능성 = 행위 호환성 = 동일한 책임의 수행

## 객체의 모양을 결정하는 협력

### 흔한 오류

- 객체는 데이터를 저장하기 위해 존재하는게 아니라 행위를 수행하며 협력에 참여하기 위함!
- 중요한 것은 정적인 클래스가 아니라 협력에 참여하는 동적인 객체!

클래스를 중심으로 설계하는 이유는 객체를 독립적으로 바라보기 때문이다. 그럼 안된다.

### 협력을 따라 흐르는 객체의 책임

협력 설계!

- 협력에 참여하는 객체들이 주고받을 요청과 응답의 흐름 결정 → 협력에 참여하기 위해 수행될 책임!
1. 협력을 구성하는 책임 고안 후 수행할 객체를 선택
2. 책임을 할당하고 나면 행동을 정의
3. 행동이 결정되면 객체가 필요한 데이터 정의
4. 데이터와 행동이 결정된 후, 구현하는 클래스 개발 가능

충분히 자율적이며 협력적인 객체를 창조해야한다.

→ 객체를 협력적으로 만들고 그 안에서 충분히 자율적으로 만든다,, 협력이라는 바운더리 내에서 자율적으로 만든다?

## 객체지향 설계 기법

### 책임-주도 설계

책임 식별 → 객체에 할당

객체가 책임을 수행하는 중에 협력자를 찾아 책임을 할당하는 순차적 방식

객체의 책임과 상호작용에 집중아여 자율적+협조적 객체로 이루어짐

### 디자인 패턴

전문가들이 특정문제에 이미 식별해놓은 역할, 책임, 협력이 있다.

책임-주도 설계의 결과를 표현

ex) COMPOSITE 패턴

### 테스트-주도 개발

테스트를 먼저 작성 → 테스트를 통과하는 코드만 작성해서 완성

실패하는 테스트 작성 → 통과하는 가장 간단한 코드 작성(중복 가능) → 리팩터링으로 중복 제거 !! ‘작동하는 깔끔한 코드’ 얻을 수 있음

응집도가 높고 결합도가 낮은 클래스로 구성된 시스템을 개발할 수 있음

책임과 협력의 관점에서 객체를 바라볼 필요가 있다.

다양한 설계경험과 패턴에 대한 지식이 필요

테스트를 작성하기 위해 객체의 메서드를 호출하여 반환값을 검증하는것은 객체가 수행해야하는 책임에 관해 생각하는 것

# 05. 책임과 메시지

page .138 ~ 176

책임감 분산!! 나말고 누가 하겠지~

자신의 책임을 무시하려고 함

## 자율적인 책임

### 설계의 품질을 좌우하는 책임

자율성!!

객체가 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문

### 자신의 의지에 따라 증언할 수 있는 자유

책임이 자율적이어야지 객체가 자유로울 수 있음

상세한 요청은 자율성을 해칠수있음

### 너무 추상적인 책임

그렇다고 포괄적이고 추상적인 책임이 좋단것은 아님

자율성 보장과 협력의 의도를 뚜렷하게 표현할 수 있어야 함

### ‘어떻게’ 가 아니라 ‘무엇’을

방법 말고 얻고싶은 결과를 말하라

### 책임을 자극하는 메시지

메시지는 객체가 자신의 책임, 즉 행동을 수행하게 만드는 유일한 방법!

## 메시지와 메서드

### 메시지

메시지-전송: 객체의 행동을 유발하는 행위 객체가 다른 객체에게 접근할 수있는 유일한 방법

전송하는 메시지를 가리키는 부분을 메시지 이름, 추가적인 정보가 필요한 경우 메시지의 인자를 통해 제공

ex) 수신자.메시지이름(인자, 인자)

수신할 메시지의 모양이 객체가 수행할 책임의 모양 결정

수신자가 책임을 수행하는 방법을 변경하더라도 외부 객체는 이 사실을 모른다 - 캡슐화에 관련된 부분?

외부 객체 - 메시지만 보고 내부는 못봄 → 외부와 내부 분리

### 메서드

메시지, 방법

메서드 : 메시지를 처리하기 위해 내부적으로 선택하는 방법

메시지 수신시 처리 순서

1. 해당 메시지를 처리할 수 있는지 여부 확인
2. 메시지를 처리할 방법인 메서드 선택

### 다형성

서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것.

객체들이 다형성을 만족한다는 것은 그 객체들이 동일한 책임을 공유한다는 것.

송신자의 관점에서는 이 모든 개체들이 동일한 책임을 수행하는것. 모두 동일하다고 봄

**대체가능성**

다형성은 송신자와 수신자 간 객체 타입에 대한 결합도를 메시지에 대한 결합도로 낮춰서 달성

### 유연하고 확장 가능하고 재사용성이 높은 협력의 의미

송신자가 수신자에대한 정보가 적어도 상호 협력이 가능하면

1. 협력이 유연해진다
2. 협력이 수행되는 방식 확장 가능
3. 협력이 수행되는 방식 재사용 가능

### 송신자와 수신자를 약하게 연결하는 메시지

메시지는 결합도를 낮춰 설계를 유연, 확장가능, 재사용 가능하게 만든다

송신자와 수신자 사이 메시지라는 얇은 결합.

## 메시지를 따라라

### 객체지향의 핵심, 메시지

객체지향의 강력함 - 객체들이 주고받는 메시지로부터 나옴

클래스는 동적인 객체의 특성과 행위를 정적인 텍스트로 표현하는 추상화 도구일뿐

클래스는 객체의 속성과 행위를 담는 틀

객체를 중심으로 보면 협력을 놓칠 수 있음

객체의 내부구조는 감춰져야함. 자율성을 위해

**데이터-주도 설계**

데이터에 대한 결정 미루고 행위를 보려면 협력을 생각해야함

협력에서 벗어나 독립적인 객체를 만드는건 클래스에 초점 맞추는거랑 비슷

어떤 객체가 어떤메시지를 전송할 수 있는가와 어떤 객체가 어떤 메시지를 이해할 수 있는가? 가 중요

객체가 메시지 선택 x 메시지가 객체 선택!!

### 책임-주도 설계 다시 살펴보기

메시지를 기반으로 적절한 역할과 책임, 협력을 발견하는 것

앱이 수행하는 기능을 시스템의 책임으로 보기

### What/Who 사이클

**어떤 행위(메시지)**가 필요한지를 결정하고 이를 수행할 객체 결정

협력에서 책임을 결정하는 것은 메시지

수신가능한 메시지가 모여 객체의 인터페이스를 구성

### 묻지 말고 시켜라

= 데메테르 법칙

메시지 중심의 설계는 메시지 수신자의 캡슐화 증진, 느슨하게 결합

송신자는 수신자를 몰라도 잘 처리할거라고 믿고 메시지 전송

자율적인 객체들의 공동체!!

모든 객체는 자신의 상태를 기반으로 스스로 결정

객체는 다른 객체의 상태를 묻지 말아야함

어떻게 → 무엇 은 인터페이스 크기 작게 함

인터페이스 크기가 작은건 외부에서 해당 객체의 의존성이 낮아짐

→ 송신자와 수신자 간 결합도 낮아져서 설계 유연, 의도 명확

### 메시지를 믿어라

메시지를 이해할 수 있다면 다양한 타입의 객체로 협력대상 교체 가능

## 객체 인터페이스

### 인터페이스

인터페이스 : 어떤 두 사물이 마주치는 경계에서 상호작용할 수 있게 이어주는 장치

1. 사용법을 익히면 내부구조를 몰라도 대상조작/의사전달 가능
2. 내부구성이나 작동방식 변경은 사용자에게 영향 x
3. 대상이 변경돼도 아무런 문제 x

### 메시지가 인터페이스를 결정한다

객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성

### 공용 인터페이스

ex) 증언하라 라는 메시지의 인터페이스

인터페이스가 결정되고 객체가 이를 수신할 경우 책임을 자율적으로 수행

### 책임, 메시지, 그리고 인터페이스

공용인터페이스는 객체의 내부와 외부를 명확히 분리

## 인터페이스와 구현의 분리

### 객체 관점에서 생각하는 방법

- 더 추상적인 인터페이스

  구체적이면 객체의 자율성 저해

- 최소 인터페이스

  외부에 사용할 필요 없는건 노출 x → 그래야 내부 수정해도 외부에 영향 덜 미침

- 인터페이스와 구현 간 차이가 있다는 걸 인식

### 구현

객체지향에서 내부 구조와 작동 방식을 가리킴

객체의 상태, 행동

### 인터페이스와 구현의 분리 원칙

why? 소프트웨어는 항상 변경되니깐 영향 최소화

송신자와 수신자가 구현이 아니라 인터페이스에 대해서만 결합되어야함

### 캡슐화

객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것

- **상태와 행위**

  = 데이터 캡슐화

  상태와 행위를 하나로 묶고 외부에서 반드시 접근해야 하는 행위만 골라 공용인터페이스로 노출

  상태- 데이터, 행동- 프로세스

- **사적인 비밀**

  구현과 관련되 세부사항은 인터페이스 뒤로 숨김

  외부의 불필요한 공격과 간섭으로부터 내부상태 격리


## 책임의 자율성이 협력의 품질을 결정한다

협력의 방식은 여러가지

책임의 자율성의 장점

1. 협력을 단순하게 만든다
2. 객체의 외부와 내부를 명확히 분리
3. 내부를 변경해도 외부에 영향 x
4. 협력의 대상을 다양하게 선택할 수 있는 유연성 제공
5. 객체의 역할을 이해하기 쉬워짐

책임이 자율적

→ 적절하게 추상화, 응집도 높아짐, 결합도 낮아짐, 캡슐화 증진, 인터페이스와 구현이 명확히 분리, 설계 유연성, 재사용성 향상